.program st506_rdgt
.fifo txrx // keep FIFO unjoined to make it smaller
.out 2 left auto 32
.side_set 2 opt

// TX FIFO:
// - 31..30 - pulse pin levels
// - 29..16 - pulse length -3
// - 15..0  - gap length -2

.wrap_target
	// output pulse pin levels
	out pins, 2

	// fetch pulse length
	out x, 14
loop_pulse:
	// loop during the pulse
	jmp x-- loop_pulse

	// fetch gap length, clear both pins
	out x, 16 side 0b00
loop_gap:
	// loop during the gap
	jmp x-- loop_gap
.wrap

% c-sdk {
static inline void st506_rdgt_program_init(
	PIO pio,
	uint sm,
	uint offset,
	uint pin_index,
	uint pin_servo_gate,
	uint freq
) {
	float clkdiv	= (float)clock_get_hz(clk_sys) / (float)(freq * 1);
	uint pin_first	= (pin_index > pin_servo_gate) ? pin_servo_gate : pin_index;
	pio_sm_config c = st506_rdgt_program_get_default_config(offset);
	sm_config_set_clkdiv(&c, clkdiv);
	sm_config_set_out_pin_base(&c, pin_first);
	sm_config_set_sideset_pin_base(&c, pin_first);
	pio_sm_init(pio, sm, offset, &c);
	pio_sm_set_consecutive_pindirs(pio, sm, pin_first, 2, true);
}

static inline void st506_rdgt_program_fill_data(
	uint *rdgt_data,
	uint rdgt_cnt,
	uint pulse_len,
	uint gap_len,
	uint pin_index,
	uint pin_servo_gate
) {
	uint index		= 0b11;
	uint servo_gate = (pin_index + 1 == pin_servo_gate) ? 0b10 : 0b01;
	for (uint i = 0; i < rdgt_cnt; i++) {
		rdgt_data[1 + i] = (servo_gate << 30) | ((pulse_len - 3) << 16) | ((gap_len - 2) << 0);
	}
	// before any pulses, add a gap that lasts for duration of 5 words
	// this makes the RDGT pulses aligned with data generated by RDDT,
	// which, when triggered, still has 5 words to shift out from
	// the previous run (4x FIFO + OSR)
	// while not strictly necessary, it makes the resulting signals look better
	rdgt_data[0] = (5 * 32) - 5;
	// first pulse has INDEX=1
	rdgt_data[1] |= (index << 30);
	// last gap can be short (it will stall waiting for data anyway)
	// this makes sure that RDGT finishes before RDDT
	rdgt_data[rdgt_cnt] &= 0xFFFF0000;
}

//          +0x0       +0x4         +0x8         +0xC (Trigger)
// Alias 0: READ_ADDR  WRITE_ADDR   TRANS_COUNT  CTRL
// Alias 1: CTRL       READ_ADDR    WRITE_ADDR   TRANS_COUNT
// Alias 2: CTRL       TRANS_COUNT  READ_ADDR    WRITE_ADDR
// Alias 3: CTRL       WRITE_ADDR   TRANS_COUNT  READ_ADDR

static int st506_rdgt_chan		= -1;
static int st506_rdgt_ctrl_chan = -1;
static int st506_rdgt_work_chan = -1;
static int st506_rdgt_trig_chan = -1;

static uint st506_rdgt_ctrl_block[5][2];
static uint st506_rdgt_ctrl_addr = (uint)&st506_rdgt_ctrl_block;

static uint st506_rdgt_rdgt_data;
static uint st506_rdgt_rddt_data;
static uint st506_rdgt_rdgt_cnt;
static uint st506_rdgt_rddt_cnt;

static inline void st506_rdgt_program_start(
	PIO pio,
	uint sm,
	uint rddt_chan,
	const uint *rdgt_data,
	const uint *rddt_data,
	uint rdgt_cnt,
	uint rddt_cnt
) {
	st506_rdgt_chan		 = dma_claim_unused_channel(true);
	st506_rdgt_ctrl_chan = dma_claim_unused_channel(true);
	st506_rdgt_work_chan = dma_claim_unused_channel(true);
	st506_rdgt_trig_chan = dma_claim_unused_channel(true);

	// initialize the Control Channel and Worker Channel
	st506_pio_init_ctrl_chan(st506_rdgt_ctrl_chan, st506_rdgt_work_chan);

	// RDGT Channel
	// - copy data to PIO's TX FIFO
	// - don't start the transfer and don't initialize the read address
	dma_channel_config rdgt_config = dma_channel_get_default_config(st506_rdgt_chan);
	channel_config_set_transfer_data_size(&rdgt_config, DMA_SIZE_32);
	channel_config_set_read_increment(&rdgt_config, true);
	channel_config_set_write_increment(&rdgt_config, false);
	channel_config_set_dreq(&rdgt_config, pio_get_dreq(pio, sm, true));
	dma_channel_configure(
		st506_rdgt_chan,
		&rdgt_config,
		/* write_addr= */ &pio->txf[sm],
		/* read_addr= */ NULL,
		/* transfer_count= */ 0,
		/* trigger= */ false
	);

	// Control Block
	//   -> set read addresses of RDGT and RDDT Channels
	//   -> trigger both channels by setting transfer count
	// 1. 'rdgt_data' -> RDGT Channel's read address
	st506_rdgt_rdgt_data		= (uint)rdgt_data;
	st506_rdgt_ctrl_block[0][0] = (uint)&st506_rdgt_rdgt_data;
	st506_rdgt_ctrl_block[0][1] = (uint)&dma_hw->ch[st506_rdgt_chan].read_addr;
	// 2. 'rddt_data' -> RDDT Channel's read address
	st506_rdgt_rddt_data		= (uint)rddt_data;
	st506_rdgt_ctrl_block[1][0] = (uint)&st506_rdgt_rddt_data;
	st506_rdgt_ctrl_block[1][1] = (uint)&dma_hw->ch[rddt_chan].read_addr;
	// 3. 'rdgt_cnt' -> RDGT Channel's transfer count (trigger)
	st506_rdgt_rdgt_cnt			= (uint)rdgt_cnt;
	st506_rdgt_ctrl_block[2][0] = (uint)&st506_rdgt_rdgt_cnt;
	st506_rdgt_ctrl_block[2][1] = (uint)&dma_hw->ch[st506_rdgt_chan].al1_transfer_count_trig;
	// 4. 'rddt_cnt' -> RDDT Channel's transfer count (trigger)
	st506_rdgt_rddt_cnt			= (uint)rddt_cnt;
	st506_rdgt_ctrl_block[3][0] = (uint)&st506_rdgt_rddt_cnt;
	st506_rdgt_ctrl_block[3][1] = (uint)&dma_hw->ch[rddt_chan].al1_transfer_count_trig;
	// 5. Finish by writing zero to the trigger register
	st506_rdgt_ctrl_block[4][0] = 0;
	st506_rdgt_ctrl_block[4][1] = 0;

	// chain the RDDT Channel to the Trigger Channel
	uint ctrl = dma_hw->ch[rddt_chan].al1_ctrl;
	ctrl &= ~DMA_CH0_CTRL_TRIG_CHAIN_TO_BITS;
	ctrl |= st506_rdgt_trig_chan << DMA_CH0_CTRL_TRIG_CHAIN_TO_LSB;
	dma_hw->ch[rddt_chan].al1_ctrl = ctrl;

	// Trigger Channel
	// - trigger the Control Channel by setting the Control Block as its read address
	dma_channel_config trig_config = dma_channel_get_default_config(st506_rdgt_trig_chan);
	channel_config_set_transfer_data_size(&trig_config, DMA_SIZE_32);
	channel_config_set_read_increment(&trig_config, false);
	channel_config_set_write_increment(&trig_config, false);
	dma_channel_configure(
		st506_rdgt_trig_chan,
		&trig_config,
		/* write_addr= */ &dma_hw->ch[st506_rdgt_ctrl_chan].al3_read_addr_trig,
		/* read_addr= */ &st506_rdgt_ctrl_addr,
		/* transfer_count= */ 1,
		/* trigger= */ true
	);

	pio_sm_set_enabled(pio, sm, true);
}

static inline void st506_rdgt_program_stop(PIO pio, uint sm) {
	pio_sm_set_enabled(pio, sm, false);
	if (st506_rdgt_trig_chan >= 0) {
		dma_channel_cleanup(st506_rdgt_trig_chan);
		dma_channel_unclaim(st506_rdgt_trig_chan);
		st506_rdgt_trig_chan = -1;
	}
	if (st506_rdgt_work_chan >= 0) {
		dma_channel_cleanup(st506_rdgt_work_chan);
		dma_channel_unclaim(st506_rdgt_work_chan);
		st506_rdgt_work_chan = -1;
	}
	if (st506_rdgt_ctrl_chan >= 0) {
		dma_channel_cleanup(st506_rdgt_ctrl_chan);
		dma_channel_unclaim(st506_rdgt_ctrl_chan);
		st506_rdgt_ctrl_chan = -1;
	}
	if (st506_rdgt_chan >= 0) {
		dma_channel_cleanup(st506_rdgt_chan);
		dma_channel_unclaim(st506_rdgt_chan);
		st506_rdgt_chan = -1;
	}
}
%}
